<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Report for <%= host %></title>
  <script type="text/javascript" src="http://nstielau.github.com/autograph/js/jquery.js"></script>
  <script type="text/javascript" src="http://nstielau.github.com/autograph/js/jquery.flot.js"></script>
  <style type="text/css">
  body,
  html {margin:0;padding:0;color:#000; }
  body { min-width:950px; }
  #wrap {margin:0 auto;width:950px;}
  #header h1 {padding:5px;margin:0;text-align: center;}
  #header h3 { margin: 0; }
  #nav { padding: 5px; }
  #nav ul{margin:0;padding:0;list-style:none;}
  #nav li{display:inline;margin:0; padding:0; }
  #main { float:right; width:700px; }
  #main h2, #main h3, #main p { padding:5px 0; }
  #sidebar {float:left;width:240px;  }
  #sidebar ul { margin-bottom: 0; }
  #sidebar h3, #sidebar p { padding:0 10px 0 0; }
  #footer { clear:both; }
  #footer p { padding:5px;margin:0; }
  </style>
</head>
<body>
<div id="wrap">
  <div id="header">
    <h1>Load testing report</h1>
    <h3>Date: <%= date %></h3>
    <h3>Host: <%= host %></h3>
  <div id="nav">

  </div>
  <div id="sidebar">
    <% if notes %>
      <h3>Report Notes</h3>
      <p><%= notes %></p>
    <% end %>
    <h3>Tests</h3>
    <div id="choices"></div>

  </div>
  <div id="main">
    <% graphs.each_pair do |k,g| %>
      <h2><%= g.title %></h2>
      <div class="flot-graph" id="<%= k %>" style="width:600px;height:300px;"></div>
    <% end %>

<div id="graph_discussion">
  <h2>Discussion</h2>
  <h3>Methods</h3>
  <p>
    Use <a href="http://www.hpl.hp.com/research/linux/httperf/">httperf</a> to load different pages a fixed number of times, at a fixed rate, and record the response time and rate at which connections are accepted.  By varying the rate, we can see how the response time and connection rate are effected by increased load on the server.  Unlike log analysis, which relies on extrapolation to guess at maximum requests/second, Autograph actually stresses the system and yields real-world results.
  </p>
  <h3>Goals</h3>
  <p>
    Autograph will help you
    <ul>
      <li>Compare the relative 'weight' of different pages, hopefully pointing you to which pages need more some caching or other form of optimization.</li>
      <li>Determine rough maximum request rates that either a) block other calls, or b) increase response time beyond an acceptable limit.</li>
    </ul>
  </p>
  <h3>Graphs</h3>
  <h4>Demanded vs. Achieved request rate</h4>
  <p>
  Ideally, this graph would be a straight line at 45 degrees; for every request that is sent to the server, it accepts a connection, regardless of how many concurrent requests are made.  Realistically, this graph will start linear and degrade as network or software bottlenecks are hit. The point at which this graph breaks linearity indicates the maximum possible concurrent requests the system can successfully serve.
  </p>
  <h4>Demanded Request Rate vs. response time</h4>
  <p>
  Ideally, this graph would be flat and low, indicating consistent and fast responses times.  Realistically, this graph will either be slightly angled or flat followed by a dramatic uptick.  The point at which the response times dramatically increase will coincide with the point at which it cannot serve all requests.
  </p>
</div>

  <h2>Report Tables</h2>
    <% reports.each do |uri, report| %>
      <div id="page_<%= uri %>" class='report' >
        <p>Test data for <%= "http://#{host}#{uri}" %></p>
          <%= report.to_html %>
      </div>
    <% end %>
  </div>
  <div id="footer" align="center">
    <p>Generated at <%= date %></p>
    <div>
    <p><a onclick="document.getElementById('command_container').style.display = 'block';">Show Command<a/></p>
    <div id="command_container" style="display:none">
      <pre><%= command_run %></pre>
    </div>
    </div>
  </div>
</div>
  <script language="javascript" type="text/javascript">
    var acolor;
    var default_graph_options = {
      series: {
        lines: { show: true, lineWidth: 3 },
        points: { show: true, radius: 4 }
      },
      legend: {
        show: true,
        backgroundColor: '#FFF',
        backgroundOpacity: 0.9
      },
      series: {
        lines: { show: true, lineWidth: 3 },
        points: { show: true, fill: false },
        shadowSize: 0,
      },
      xaxis: {},
      yaxis: {
        show: true,
      },
      grid: {
        show: true,
        backgroundColor: null,
        borderWidth: 2,
        hoverable: true,
        tickColor: "#E1E8F0",
      },
      colors: ["#5bba47","#d86b6d","#3d8aea","#333333"]
    };

    // Callback function to show the tooltip
    function showTooltip(item) {
      var contents = "(" + item.datapoint[1] + "," + item.datapoint[0] + ")";
      var x = item.pageX;
      var y = item.pageY - 10;

      var obj = $('<div id="flot-tooltip">' + contents + '</div>').css( {
        padding: '5px',
        position: 'absolute',
        minWidth: '5em',
        display: 'block',
        top:  y+5,
        left: x+5,
        zIndex: 9999
      });

      obj.appendTo('body').fadeIn('200');
    }

    // Var to hold our previous point
    var previousPoint = null;

    // Bind to the plothover so we can show a tooltip
    $(".flot-graph").bind("plothover", function (event, pos, item) {
      if (item) {
        if (previousPoint != item.datapoint) {
          previousPoint = item.datapoint;
          $("#flot-tooltip").remove();
          showTooltip(item);
        }
      } else {
        $('#flot-tooltip').remove().fadeOut('200');
        previousPoint = null;
      }
    });

    var request_rate_datasets = {
<%=
  dataset_id=0;
  data_string = graphs[:request_rate].series.map do |s|
    points = []
    s.x_values.each_with_index do |x,i|
      points << "[#{s.x_values[i]}, #{s.y_values[i]}]"
    end
    "'#{dataset_id=dataset_id+1}' : {label:  \"#{s.label}\", data: [#{points.join(", ")}]}"
  end.join(", \n")
  # ideal_points = graphs[:request_rate].series[0].x_values.map{|x|"[#{x},#{x}]"}
  # data_string + ",'#{dataset_id=dataset_id+1}' : {label:  \"Ideal\", data: [#{ideal_points.join(", ")}]}"
  data_string
%>
    };

    var response_time_datasets = {
<%=
  dataset_id=0;
  data_string = graphs[:response_time].series.map do |s|
    points = []
    s.x_values.each_with_index do |x,i|
      points << "[#{s.x_values[i]}, #{s.y_values[i]}]"
    end
    "'#{dataset_id=dataset_id+1}' : {label:  \"#{s.label}\", data: [#{points.join(", ")}]}"
  end.join(", \n")
  data_string
%>
    };

        var max_request_rate_datasets = [
    <%=
      data_strings = []
      data_string = graphs[:max_request_rate].series.each_with_index do |s, index|
        data_strings << "{label:  \"#{s.label}\", data: [[#{index}, #{s.y_values[0]}]]}"
      end
      data_strings.join(", \n")
    %>
        ];

    // hard-code color indices to prevent them from shifting as
    // countries are turned on/off
    var i = 0;
    $.each(request_rate_datasets, function(key, val) {
        val.color = i;
        ++i;
    });
    i = 0;
    $.each(response_time_datasets, function(key, val) {
        val.color = i;
        ++i;
    });

    // insert checkboxes
    var choiceContainer = $("#choices");
    $.each(request_rate_datasets, function(key, val) {
        choiceContainer.append('<br/><input type="checkbox" name="' + key +
                               '" checked="checked" id="id' + key + '">' +
                               '<label for="id' + key + '">'
                                + val.label + '</label>');
    });
    choiceContainer.find("input").click(plotAccordingToChoices);


    function plotAccordingToChoices() {
        var data1 = [];
        var data2 = [];

        choiceContainer.find("input:checked").each(function () {
            var key = $(this).attr("name");
            if (key && request_rate_datasets[key])
                data1.push(request_rate_datasets[key]);
              if (key && response_time_datasets[key])
                  data2.push(response_time_datasets[key]);
        });

        if (data1.length > 0)
            $.plot($("#request_rate"), data1, default_graph_options);


        if (data2.length > 0)
            $.plot($("#response_time"), data2, default_graph_options);
    }

    plotAccordingToChoices();
    $.plot($("#max_request_rate"), max_request_rate_datasets, $.merge({series: {lines: {show: false}, bars : {show: true}}}, default_graph_options));


</script>
</body>
</html>

